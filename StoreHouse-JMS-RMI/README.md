# StoreHouse
![alt text](https://raw.githubusercontent.com/Aledangelo/AdvancedComputerProgramming/main/StoreHouse-JMS-RMI/diagram.png)
System for managing a warehouse based on message code. The system implements an article deposit and consists of 3 entities shown in the figure:
* **Client**: The client sends N messages on the Request queue. Each message contains 2 pieces of information: (i) type of request (insert or get) and (ii) article_id (represented by an integer). The client spawns two threads, sender and receiver, which operate as a client of a JMS provider, using the Point-to-Point paradigm. The first thread sends N messages on a Request queue. Each message contains two pieces of information: (i) type of request (deposit or withdraw) and (ii) article_id (represented by an integer). The second thread listens, through asynchronous communication, for responses to "pick up" messages sent by the server to a Response queue.
* **Proxy**: This entity acts as an intermediary between requests sent from the client to the server. The proxy takes care of fetching client requests from the Request queue (managed by the JMS provider), and forwards them to the remote service called Server. The proxy therefore generates a receiver thread, which listens (asynchronous communication) for messages from the client on the Request queue, extracts the information (type of request, value), and invokes the corresponding fetch or deposit method of the remote service. If the message is pick up, the receiver thread creates and starts a sender thread that takes care of forwarding the response from the server to the client on the Response queue. If the message is of type "deposit", the thread sender is not created.
* **Server**: The server will need to be implemented as an RMI remote service. The server displays an interface with the withdraw and deposit methods used by the Proxy to withdraw and deposit items from / in the circular queue. The service that implements the withdrawal and deposit interface is offered through RMI. The queue size is 5. When the queue is full, the thread making a deposit is put on hold; similarly, if the queue is empty, the thread doing a fetch is put on hold. Access to the queue is managed in mutual exclusion to manage the hypothetical case of multiple proxies connecting at the same time.

1 client generate 10 messages. Request type and article_id are generated randomly.